## 多线程记录篇

#### 1、多线程的几个概念

**同步**：Synchronous，即调用方法开始，一旦调用就必须等待方法执行完返回才能继续下面的操作。

如：去ATM取钱，必须要等ATM吐完钱并且拿到钱取出卡才能离开。

**异步**：Asynchronous，即不关心方法的执行过程，触发要调用的方法就继续执行下面的操作，不会像同步那样阻塞直到方法完成才继续。

如：这次要取钱，数量较大，你直接电话或者APP预约银行说你要取多少万现金，这段时间银行会为你准备钱，而这与你都没什么关系，然后你只要按预定的时候去取就行了，对你于而言，你们是触发了一个异步动作而已。

**并发**：Concurrency，即一段时间内多个任务在执行，但不一定是同时在执行，他们可能是在**交替**在运行，也有可能是串行运行的。

**并行**：Parallelism，这个就是多个任务在**同时执行**，可以理解为并发里面有一部分任务在并行执行。

单核CPU不会有并行操作，应为一个CPU一次只能执行一条指令，并行操作只存在于多核CPU中。

**阻塞**：Blocking，如果一个线程占用了一个公共资源而没有释放对它的锁，另外对别的一些线程想要继续执行就只能等它释放锁，这时候就造成了阻塞了。

**非阻塞**：Non_Blocking，就是没有阻塞，线程可以自由运行，没有锁定公共资源，不相互阻塞运行。



#### 2、实现多线程的三种方式：

- **继承Thread类**

- **实现Runnable接口**

- **实现Callable接口**

  通过实现Callable接口并重写call方法，并把Callable实例传给FutureTask对象，再把FutureTask对象传给Thread对象。它与Thread、Runnable最大的不同是Callable能返回一个异步处理的结果Future对象并能抛出异常，而其他两种不能。

  代码：https://mp.weixin.qq.com/s/39Sb60J0DC2mNN6DYvpFtg



#### 3、线程的状态和生命周期：

![1567047757980](images/20190716001946387.png)

这些状态的枚举都定义在java.lang.Thread.State下。

**NEW**：表示刚创建的线程，还没有开始启动。

**RUNNABLE**：表示线程已经出发start方式调用，线程正式启动，线程处于运行中状态。

**BLOCKED**：表示线程阻塞，等待获取锁，如碰到synchronized、lock等关键字占用临界区的情况，一旦获取到锁就进行RUNNABLE状态继续运行。

**WAITING**：表示贤臣处于无限制等待状态，等待一个特殊的时间来重新唤醒，如通过wait方法进行等待的线程等待一个notify()或者notifyAll()方法，通过join()方法进行等待的线程等待目标线程运行结束而唤醒，一旦通过相关事件唤醒线程，线程就进入了RUNNABLE状态继续运行。

**TIMED_WAITING**：表示线程进入了一个有时限的等待，如sleep(3000),等待三秒后线程重新进行RUNNABLE状态继续运行。

**TERMINATED**：表示线程执行完毕后，进行终止状态。

注意：一旦线程通过start()方法启动后就再也不能回到初始NEW状态，线程终止后也不能再回到RUNNABLE状态。



#### 4、多线程中的死锁、活锁、饥饿和无锁

死锁、活锁、饥饿是关于多线程是否活跃出现的运行阻塞障碍问题，如果线程出现了这三种情况，即线程不再活跃，不能再正常的执行下去了。

**死锁**：死锁是多线程中最差的一种情况，多个线程相互占用对方的资源的锁，而又相互等对方释放锁，此时若无外力干预，这些线程则一直处理阻塞的假死状态，形成死锁。

如：A同学抢了B同学的钢笔，B同学抢了A同学的书，两个人都相互占用对方的东西，都在让对方先还给自己，自己再还，这样一直争下去等待对方还得不到解决，老师知道此事后就让他们相互还给对方，这样在外力的干预下他们才解决，这事其实很好解决，但计算机不像人，如果发现这种情况没有外力干预，还是会一直阻塞下去。

**活锁**：活锁与死锁相反，死锁是大家都拿不到资源都占用着对方的资源，而活锁是拿到资源却又相互释放不执行。当多线程中出现了相互谦让，都主动将资源释放给别的线程使用，这样这个资源在多个线程之间跳动而又得不到执行，这就是活锁。

**饥饿：**多线程中有线程优先级，优先级高的线程能够插队并优先执行，这样如果优先级高的线程一直抢占优先级低线程的资源，导致低优先级线程无法得到执行，这就是饥饿。当然还有一种饥饿情况，一个线程一直占着一个资源不放而导致其他线程得不到执行，与死锁不同的是饥饿在以后一段时间内还是能够得到执行的，如果那个占用资源的线程结束了并释放了资源。

**无锁**：即没有对资源进行锁定，即所有的线程都能访问并修改同一个资源，但同时只有一个线程能修改成功。无锁的典型的特定就是一个无锁典型的特点就是一个修改操作在一个循环内进行，线程会不断的尝试修改共享资源，如果没有冲突就修改成功并退出否则就会继续下一次循环尝试。所以，如果有多个线程修改同一个值必定会有一个线程能修改成功，而其他修改失败的线程会不断重试直到修改成功。之前的文章我介绍过JDK的CAS原理及应用即是无锁的实现。

可以看出，无锁是一种非常良好的设计，它不会出现线程出现的跳跃性问题，锁使用不当肯定会出现系统性能问题，虽然无锁无法全面代替有锁，但无锁在某些场合下是非常高效的。

#### 5、Java内存模型

- Java的多线程之间是通过共享内存进行通信的，在通信过程中会存在一系列如可见性、原子性、有序性等问题，而JMM就是围绕着多线程通信以及与其相关的一系列特性而建立的模型。JMM定义了一些语法集，这些语法集映射到Java语言中就是volatile、synchronized等关键字。

- java内存模型规定了所有的变量都存储在主内存中，每条线程还有自己的工作内存（本地内存），线程的工作内存（本地内存）中保存了该线程中是用到的变量的主内存副本拷贝。线程对变量的所有操作都必须在工作内存（本地内存）中进行，而不能直接读写主内存。不同线程之间也无法直接访问对方工作内存（本地内存）中的变量，线程间变量的传递均需要自己的工作内存（本地内存）和主存之间进行数据同步进行。

  ![jmm](imagesMM过程.png)

  #### 6、线程池的执行流程

  线程池：一种线程使用模式。线程过多会带来调度开销，进而影响缓存局部性和整体性能。而线程池维护着多个线程，等待着监督管理者分配可并发执行的任务，这避免了在处理短时间任务时创建和销毁线程的代价。线程池执行流程是每个开发必备的。

  **执行流程：**

  - 提交一个任务，线程池里存活的核心线程数小于线程数corePoolSize，线程池会创建一个核心线程去处理提交的任务。
  - 如果线程池核心线程数已满，即线程数已经等于corePoolSize，一个新提交的任务，会被放进任务队列workQueue排队等待执行。
  - 当线程池里面存活的线程数已经等于corePoolSize了，并且任务队列workQueue也满，判断线程数是否达到maximumPoolSize，即最大线程数是否已满，如果没有到达，创建一个非核心线程执行提交的任务。
  - 如果当前的线程数达到了maximumPoolSize，还有新的任务过来的话，直接采用拒绝策略处理。

  **JDK提供了四种拒绝策略处理类**

  - AbortPolicy（抛出一个异常，默认的）
  - DiscardPolicy（直接丢弃任务）
  - DiscardOldestPolicy（丢弃队列里最老的任务，将当前这个任务继续提交给线程池）
  - CallerRunsPolicy（交给线程池调用所在的线程进行处理）
